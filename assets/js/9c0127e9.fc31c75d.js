"use strict";(self.webpackChunkchialisp_web=self.webpackChunkchialisp_web||[]).push([[3556],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(n),h=r,k=u["".concat(s,".").concat(h)]||u[h]||d[h]||i;return n?a.createElement(k,l(l({ref:t},m),{},{components:n})):a.createElement(k,l({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5382:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return m},default:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],o={id:"clvm",title:"CLVM Reference Manual",sidebar_label:"CLVM Reference"},s=void 0,p={unversionedId:"ref/clvm",id:"ref/clvm",isDocsHomePage:!1,title:"CLVM Reference Manual",description:"The clvm is a small, tightly defined VM that defines the semantics of CLVM programs run during Chia blockchain validation. It serves as a target language for higher level languages, especially ChiaLisp.",source:"@site/docs/ref/clvm.md",sourceDirName:"ref",slug:"/ref/clvm",permalink:"/docs/ref/clvm",editUrl:"https://github.com/Chia-Network/chialisp-web/edit/main/docs/ref/clvm.md",version:"current",frontMatter:{id:"clvm",title:"CLVM Reference Manual",sidebar_label:"CLVM Reference"},sidebar:"someSidebar",previous:{title:"The Great Chia Glossary",permalink:"/docs/glossary"},next:{title:"Serialization",permalink:"/docs/ref/serialization"}},m=[{value:"Definitions",id:"definitions",children:[]},{value:"Types",id:"types",children:[{value:"Atoms as Byte Arrays",id:"atoms-as-byte-arrays",children:[]},{value:"Unsigned Integer",id:"unsigned-integer",children:[]},{value:"Signed Integer",id:"signed-integer",children:[]},{value:"BLS Point",id:"bls-point",children:[]}]},{value:"Treeargs : Program Arguments, and Argument Lookup",id:"treeargs--program-arguments-and-argument-lookup",children:[{value:"Illustration of argument numbering",id:"illustration-of-argument-numbering",children:[]}]},{value:"Quoting",id:"quoting",children:[{value:"Compilation: Atom Syntax",id:"compilation-atom-syntax",children:[]}]},{value:"Operators are atoms too..",id:"operators-are-atoms-too",children:[]},{value:"Errors",id:"errors",children:[]},{value:"The built-in opcodes",id:"the-built-in-opcodes",children:[]},{value:"List Operators",id:"list-operators",children:[]},{value:"Control Flow",id:"control-flow",children:[]},{value:"Constants",id:"constants",children:[]},{value:"Integer Operators",id:"integer-operators",children:[{value:"Rounding",id:"rounding",children:[]},{value:"Division of negative numbers",id:"division-of-negative-numbers",children:[]},{value:"Flooring of negative nubmers",id:"flooring-of-negative-nubmers",children:[]}]},{value:"Bit Operations",id:"bit-operations",children:[]},{value:"Shifts",id:"shifts",children:[]},{value:"Strings",id:"strings",children:[]},{value:"Streaming Operators",id:"streaming-operators",children:[]},{value:"BLS12-381 operators",id:"bls12-381-operators",children:[]},{value:"softfork",id:"softfork",children:[]},{value:"Arithmetic and Bitwise Identities",id:"arithmetic-and-bitwise-identities",children:[]},{value:"Arithmetic",id:"arithmetic",children:[{value:"Behaviour of nil when used as an integer",id:"behaviour-of-nil-when-used-as-an-integer",children:[]},{value:"Behaviour of zero when used as a value that may be checked for nil",id:"behaviour-of-zero-when-used-as-a-value-that-may-be-checked-for-nil",children:[]}]},{value:"Costs",id:"costs",children:[]}],d={toc:m};function u(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The clvm is a small, tightly defined VM that defines the semantics of CLVM programs run during Chia blockchain validation. It serves as a target language for higher level languages, especially ChiaLisp."),(0,i.kt)("h2",{id:"definitions"},"Definitions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"CLVM Assembly")," - The textual representation of a CLVM program."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"CLVM Bytecode")," - The serialized form of a CLVM program."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ChiaLisp")," - A higher-level language, built on top of CLVM."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"CLVM Object")," - The underlying data type in the CLVM. An atom or a cons pair."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Atom")," - The datatype for values in the CLVM. Atoms are immutable byte arrays. Atoms are untyped and are used to encode all strings, integers, and keys. The only things in the CLVM which are not atoms are cons pairs. Atom properties are length, and the bytes in the atom."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"cons pair")," - An immutable ordered pair of references to other CLVM objects. One of two data types in the CLVM. The syntax for a cons pair is a dotted pair. Also called ",(0,i.kt)("inlineCode",{parentName:"li"},"cons cell")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"cons box"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"slot")," - One of the cells in a cons box. right or left. Accessed with ",(0,i.kt)("inlineCode",{parentName:"li"},"f")," (first) or ",(0,i.kt)("inlineCode",{parentName:"li"},"r")," (rest)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"nil")," - nil is the special value represented by the zero length byte array. This value represents zero, the empty string, false, and the empty list. Nil is represented in CLVM assembly as ",(0,i.kt)("inlineCode",{parentName:"li"},"()"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"''"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Value")," - We use value to mean an abstract value like ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," (an integer), ",(0,i.kt)("inlineCode",{parentName:"li"},"0xCAFE")," (a byte string), ",(0,i.kt)("inlineCode",{parentName:"li"},'"hello"')," (a string) or ",(0,i.kt)("inlineCode",{parentName:"li"},'(sha256 (q . "hello"))')," (a program). Values are represented by CLVM Objects."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"List")," - CLVM lists follow the lisp convention of being a cons pair containing the first list element in the left slot and the rest of the list in the right slot."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Proper List"),' - A "proper" list is a chain of cons boxes, each containing a value in the left slot. Each right slot contains either another cons box, or nil, if it is the last pair.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Function")," - A function in the CLVM is either a built-in opcode or a user-defined program."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Operator")," - An opcode/string specifying a built-in function to use."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Program")," - A CLVM object which can be executed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Opcodes")," - An atom corresponding to a reserved keyword. When a list is evaluated with a pre-defined opcode in the first position, the code for that opcode is run."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Keyword")," - A reserved word in the CLVM assembly language syntax. The strings used for function lookup by the CLVM."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Tree")," - A binary tree can be formed from cons pairs and atoms by allowing the right and left cells of a cons pair to hold either an atom, or a cons pair. Atoms are the leaves of the tree."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Function Parameter")," - When a list is evaluated, the first argument is the function, and the other items are parameters. In the program ",(0,i.kt)("inlineCode",{parentName:"li"},"(+ (q . 1) (q . 2))"),", the quoted atoms ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"2")," are parameters to the operator ",(0,i.kt)("inlineCode",{parentName:"li"},"+")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Treearg")," - These are program arguments passed in from outside the program. They are referenced by integers that describe a path in the argument tree."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Argument"),' - Outside the context of the CLVM, the term "argument" can mean "program argument" (the "argv" of the C language, for example), or "function argument", among other things. Because of this potential confusion, we avoid using the term "argument" in this document. The context is especially important considering the way in which CLVM programs look up their program arguments.')),(0,i.kt)("p",null,"A CLVM program must have an unambiguous definition and meaning, so that Chia block validation and consensus is deterministic. Programs are treated as Merkle trees, uniquely identified by the hash at their root. The program hash can be used to verify that two programs are identical."),(0,i.kt)("h1",{id:"readable-assembly-format"},"Readable assembly format"),(0,i.kt)("p",null,"The in-memory objects the CLVM operates on are atoms and cons pairs, but for programming convenience there is a human readable string format for input and output. This format is what is passed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"brun")," tool. This text representation of CLVM programs and data is not used anywhere in blockchain validation and has no impact on consensus. There are multiple ways of encoding the same CLVM object in the human readable serialization format, so going backwards to pretty print a CLVM object in this format requires guessing as to the best representation."),(0,i.kt)("p",null,"Atoms in the human readable representation can be represented as directly quoted strings. They can also be expressed as decimal integers (",(0,i.kt)("inlineCode",{parentName:"p"},"100"),"), or hex literals (",(0,i.kt)("inlineCode",{parentName:"p"},"0x64"),")."),(0,i.kt)("p",null,"Cons pairs can be represented using dot as an infix operator like so: ",(0,i.kt)("inlineCode",{parentName:"p"},"(3 . 4)"),", which corresponds to a cons pair containing 3 and 4. A more common representation of data is lists, which are written as parentheses surrounding a space-delimited list of values."),(0,i.kt)("p",null,"Proper lists are built from linked cons pairs, and assume a nil terminator. For example ",(0,i.kt)("inlineCode",{parentName:"p"},"(3 4 5)")," represents the same thing as ",(0,i.kt)("inlineCode",{parentName:"p"},"(3 . (4 . (5 . nil)))"),"."),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"''"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," all are parsed to the same value, but 0x0 is not."),(0,i.kt)("h1",{id:"program-evaluation"},"Program Evaluation"),(0,i.kt)("p",null,"The syntax of CLVM assembly is similar to Lisp. It is a parenthesized ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Polish_notation"},"prefix notation")," that puts the operator before the arguments when reading left to right."),(0,i.kt)("p",null,"The semantics of the language implemented by the CLVM is similar to Lisp. A program is represented as a binary tree. The root of the tree is the least nested object in the program tree, with inner function calls embedded recursively inside of it. In the following example, the outer parentheses represent the cons box that is the root of the tree ",(0,i.kt)("inlineCode",{parentName:"p"},"(+ (q . 1) (q . 2))"),"."),(0,i.kt)("p",null,"Whenever a program is called it always has a context, or environment, which is a CLVM object. This object holds all the arguments passed into the program. This is the second command line argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"run")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"brun"),". The default environment is nil."),(0,i.kt)("p",null,"If the program is an atom then an argument lookup is performed, and the argument is returned. Please see ",(0,i.kt)("a",{parentName:"p",href:"#treeargs"},"treeargs"),", below."),(0,i.kt)("p",null,"If the the root of the program is a cons pair then all of the parameters (contained in the right slot of the cons box) are evaluated, then a function call is made and the result of that function call is returned. The object on the left determines the function to call and the object on the right determines what arguments it is passed."),(0,i.kt)("p",null,"If the object in the leftmost position of a list being executed is an operator in a list, the operator is called without first evaluating the parameters."),(0,i.kt)("p",null,'If the CLVM is running in "strict mode", an unknown opcode will abort the program. This is the mode CLVM is run in during mempool checking and block validation. During developer testing, the CLVM may be run in "non-strict" mode, which allows for unknown opcodes to be used and treated as no-ops.'),(0,i.kt)("p",null,"The quote opcode is special. When it is recognized by the interpreter, it causes whatever is on the right to be returned unevaluated. All other functions are passed the results of evaluating what's on the right first."),(0,i.kt)("p",null,"A compiled CLVM program can be thought of as a binary tree."),(0,i.kt)("p",null,'Here is an example of a function invocation (or "function call"). ',(0,i.kt)("inlineCode",{parentName:"p"},"(+ (q . 1) (q . 2))"),". The function is the opcode ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", a function built-in to the clvm runtime."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(+ (q . 1) (q . 2))")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"      [ ]\n     /   \\\n    +     [ ]\n         /   \\\n      [q, 1]  [ ]\n             /   \\\n         [q, 2]  nil\n")),(0,i.kt)("p",null,"After First Reduction"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(+ 1 2)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"      [ ]\n     /   \\\n    +     [ ]\n         /   \\\n        1     [ ]\n             /   \\\n            2    nil\n")),(0,i.kt)("p",null,"After Second Reduction, and ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," function application"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"3\n")),(0,i.kt)("p",null,"Program trees are evaluated by first evaluating the leaf nodes, then their parents, recursively.\nArguments to functions are always evaluated before the function is called.\nCLVM objects need not be evaluated in a specific order, but all child nodes must be evaluated before their parent."),(0,i.kt)("p",null,"If the item is a quoted value, the value is returned."),(0,i.kt)("p",null,"If the item is an atom, the atom is looked up as a Treearg."),(0,i.kt)("p",null,"If the item to be evaluated is a list, all of the parameters are evaluated and then the evaluated parameters are passed to the function"),(0,i.kt)("p",null,"All arguments of a function are evaluated before being passed to that function."),(0,i.kt)("h2",{id:"types"},"Types"),(0,i.kt)("p",null,"The two types of CLVM Object are ",(0,i.kt)("em",{parentName:"p"},"cons pair")," and ",(0,i.kt)("em",{parentName:"p"},"atom"),". They can be distinguished by the ",(0,i.kt)("strong",{parentName:"p"},"listp")," opcode. Atoms in the CLVM language do not carry other type information. However, similarly to the machine code instructions for a CPU, functions interpret atoms in specific predictable ways. Thus, each function imposes a type for each of its arguments."),(0,i.kt)("p",null,"The value of an atom - its length, and the values of its bytes - are always well defined and unambiguous. Because atoms have no type information, the meaning of an atom is determined when a function is applied to it. In the following example, an atom that was read in as a string is treated as an integer."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"brun '(+ (q . \"helo\") (q . 1))'")," => ",(0,i.kt)("inlineCode",{parentName:"p"},'"help"')),(0,i.kt)("p",null,"And in this example, an atom that was read in as an integer is appended to a string."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"brun '(concat (q . \"hello\") (q . 49))'")," => ",(0,i.kt)("inlineCode",{parentName:"p"},'"hello1"')),(0,i.kt)("h3",{id:"atoms-as-byte-arrays"},"Atoms as Byte Arrays"),(0,i.kt)("p",null,"The atom is treated as an array of bytes, with a length. No specific semantics are assumed, except as specified in the instruction."),(0,i.kt)("h3",{id:"unsigned-integer"},"Unsigned Integer"),(0,i.kt)("p",null,"An unsigned integer of arbitrary length. If more bits are required to perform an operation with atoms of different length, the atom is virtually extended with zero bytes to the left."),(0,i.kt)("h3",{id:"signed-integer"},"Signed Integer"),(0,i.kt)("p",null,"The byte array behaves as a two's complement signed integer. The most significant bit denotes a negative number. The underlying representation matters, because the individual bytes are viewable through other operations."),(0,i.kt)("p",null,"This type has the potential for multiple representations to be treated as the same value. For example, 0xFF and 0xFFFF both encode ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),". Integer arithmetic operations that treat returned atoms as signed integers will return the minimal representation for negative numbers, eg. ",(0,i.kt)("inlineCode",{parentName:"p"},"0xFF")," for ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")),(0,i.kt)("p",null,"These integers are byte-aligned. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"0xFFF")," is interpreted as the two bytes ",(0,i.kt)("inlineCode",{parentName:"p"},"0x0F"),",",(0,i.kt)("inlineCode",{parentName:"p"},"0xFF"),", with value ",(0,i.kt)("inlineCode",{parentName:"p"},"4095"),"."),(0,i.kt)("p",null,"This can also cause unexpected representations of numbers when they are expected to be interpreted as strings.."),(0,i.kt)("p",null,"If a positive integer's first byte is >= ",(0,i.kt)("inlineCode",{parentName:"p"},"0x80")," (the most significant bit is 1) then it will be prepended with a ",(0,i.kt)("inlineCode",{parentName:"p"},"0x00")," when the operator output type is a signed integer. Without that prepended byte, a positive value would appear negative in the case that the high bit is set.\nYou are likely to encounter this when using the output of an int operation as the input of a string operation."),(0,i.kt)("h3",{id:"bls-point"},"BLS Point"),(0,i.kt)("p",null,"This type represents a point on an elliptic curve over finite field described ",(0,i.kt)("a",{parentName:"p",href:"https://electriccoin.co/blog/new-snark-curve/"},"here"),"."),(0,i.kt)("p",null,"These values are opaque values, 48 bytes in length. The outputs of ",(0,i.kt)("inlineCode",{parentName:"p"},"pubkey_for_exp")," are BLS points. The inputs and outputs of ",(0,i.kt)("inlineCode",{parentName:"p"},"point_add")," are BLS points."),(0,i.kt)("h2",{id:"treeargs--program-arguments-and-argument-lookup"},"Treeargs : Program Arguments, and Argument Lookup"),(0,i.kt)("p",null,"For a program running on a deterministic machine to have different behaviours, it must be able to have different starting states. The starting state for a CLVM program is the program argument list - the treearg."),(0,i.kt)("p",null,"When an unquoted integer is evaluated, it is replaced with the corresponding value/CLVM Object from the program Treearg. If the argument is not found, ",(0,i.kt)("inlineCode",{parentName:"p"},"nil")," is returned."),(0,i.kt)("p",null,"As an improvement over walking the argument tree via calls to ",(0,i.kt)("strong",{parentName:"p"},"first")," and ",(0,i.kt)("strong",{parentName:"p"},"rest"),", arguments are referenced from the argument list by their argument number. This number is derived by translating a path of left and right cons slots followed from the root of the argument tree to that CLVM Object, into a series of ones and zeros. The number representing the path is read starting at the least significant bit. The number of the root of the argument tree is ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),". When the path is complete, a final ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," is appended to the msb of the number."),(0,i.kt)("h3",{id:"illustration-of-argument-numbering"},"Illustration of argument numbering"),(0,i.kt)("p",null,"We treat an s-expression as a binary tree, where leaf nodes are atoms, and cons pairs\nare nodes with two children. We then number the paths as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"              1\n             / \\\n            /   \\\n           /     \\\n          /       \\\n         /         \\\n        /           \\\n       2             3\n      / \\           / \\\n     /   \\         /   \\\n    4      6      5     7\n   / \\    / \\    / \\   / \\\n  8   12 10  14 9  13 11  15\n\netc.\n")),(0,i.kt)("p",null,"This quirky numbering makes the implementation simple."),(0,i.kt)("p",null,"Numbering starts at the root of the tree. The path index is set to 1, which represents the entire argument tree.\nBits are appended to the right of the path index as we descend, 0 for left, and 1 for right."),(0,i.kt)("p",null,"See the implementation ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Chia-Network/clvm_tools/blob/main/clvm_tools/NodePath.py"},"here")),(0,i.kt)("h2",{id:"quoting"},"Quoting"),(0,i.kt)("p",null,"In most programming languages, evaluating a literal returns the value itself.\nIn CLVM, the meaning of an atom at evaluation time (at any position of the list except the first), is a reference to a value in the argument tree. xxx"),(0,i.kt)("p",null,"Therefore, when you intend to write:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(+ 1 2)")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"3")),(0,i.kt)("p",null,"You must instead write:\n",(0,i.kt)("inlineCode",{parentName:"p"},"(+ (q . 1) (q . 2))")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"3")),(0,i.kt)("p",null,"nil is self-quoting."),(0,i.kt)("h3",{id:"compilation-atom-syntax"},"Compilation: Atom Syntax"),(0,i.kt)("p",null,"Although there is only one underlying representation of an atom, different syntaxes are recognized during compile time, and those atom syntaxes are interpreted differently during the translation from program text to CLVM Objects."),(0,i.kt)("p",null,"Nil, decimal zero and the empty string all evaluate to the same atom."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(q . ())")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"()")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(q . 0)")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"()")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'(q . "")')," => ",(0,i.kt)("inlineCode",{parentName:"p"},"()")),(0,i.kt)("p",null,"which is not the same as a single zero byte."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(q . 0x0)")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"0x00")),(0,i.kt)("h4",{id:"equivalence-of-strings-symbols-hex-strings-and-numbers"},"Equivalence of Strings, symbols, hex strings, and numbers"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'"A"')," is the same atom as ",(0,i.kt)("inlineCode",{parentName:"p"},"A")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'(q . "A") => 65\n(q . A) => 65\n(q . 65) => 65\n(q . 0x41) => 65\n')),(0,i.kt)("p",null,"However, the same is not true for Built-ins.\n",(0,i.kt)("inlineCode",{parentName:"p"},'"q"')," is not the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"q")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'(q . q) => 1\n(q . "q") => 113\n')),(0,i.kt)("h2",{id:"operators-are-atoms-too"},"Operators are atoms too.."),(0,i.kt)("p",null,"When you write a program, the first argument in the list is interpreted as an operator.\nHowever, this operator is also stored as an unsigned int.\nThis can lead to ambiguity and confusing outputs:"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(r (q . (1 2 3)))")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"(a 3)")),(0,i.kt)("p",null,"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," is at the beginning of the list, ",(0,i.kt)("inlineCode",{parentName:"p"},"brun")," assumes it is the operator and looks up its corresponding representation, which in this case is ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),".\nIt is the correct output of the program, it is just displayed in an unexpected way."),(0,i.kt)("h2",{id:"errors"},"Errors"),(0,i.kt)("p",null,"While running a clvm program, checks are made to ensure the CLVM does not enter an undefined state. When a program violates one of these runtime checks, it is said to have caused an error."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"First element in an evaluated list is not a valid function. Example: ",(0,i.kt)("inlineCode",{parentName:"li"},'("hello" (q . 1))')," => ",(0,i.kt)("inlineCode",{parentName:"li"},'FAIL: unimplemented operator "hello"')),(0,i.kt)("li",{parentName:"ul"},"Wrong number of arguments. Example: ",(0,i.kt)("inlineCode",{parentName:"li"},"(lognot (q . 1) (q . 2))")," => ",(0,i.kt)("inlineCode",{parentName:"li"},"FAIL: lognot requires 1 arg")),(0,i.kt)("li",{parentName:"ul"},"Program evaluation exceeds max cost see ",(0,i.kt)("a",{parentName:"li",href:"/docs/ref/clvm#costs"},"Costs")),(0,i.kt)("li",{parentName:"ul"},"Too many allocations have been performed"),(0,i.kt)("li",{parentName:"ul"},"Argument checking e.g. negative index ",(0,i.kt)("inlineCode",{parentName:"li"},"run '(substr \"abc\" -1 -)'"),' FAIL: invalid indices for substr ("abc" -1 17)')),(0,i.kt)("p",null,"An error will cause the program to abort."),(0,i.kt)("h1",{id:"operator-summary"},"Operator Summary"),(0,i.kt)("h2",{id:"the-built-in-opcodes"},"The built-in opcodes"),(0,i.kt)("p",null,"Opcodes are functions built in to the CLVM. They are available to any running program."),(0,i.kt)("h2",{id:"list-operators"},"List Operators"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"c")," ",(0,i.kt)("em",{parentName:"p"},"cons")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(c A B)")," takes exactly two operands and returns a cons pair with the two objects in it (A in the left, B in the right)"),(0,i.kt)("p",null,"Example: ",(0,i.kt)("inlineCode",{parentName:"p"},"'(c (q . \"A\") (q . ()))'")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"(65)")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"f")," ",(0,i.kt)("em",{parentName:"p"},"first")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(f X)")," takes exactly one operand which must be a cons pair, and returns the left half"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"r")," ",(0,i.kt)("em",{parentName:"p"},"rest")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(r X)")," takes exactly one operand which must be a cons pair, and returns the right half"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"l")," ",(0,i.kt)("em",{parentName:"p"},"listp")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(l X)")," takes exactly one operand and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," if it is an atom or ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," if it is a cons pair. In contrast to most other lisps, nil is not a list in CLVM."),(0,i.kt)("h2",{id:"control-flow"},"Control Flow"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"a")," ",(0,i.kt)("em",{parentName:"p"},"apply")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(a P A)")," run the program P with the arguments A. Note that this executes P in a new environment. Using integers to reference values in the solution will reference values in A."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"i")," ",(0,i.kt)("em",{parentName:"p"},"if")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(i A B C)")," takes exactly three operands ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),", return ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),". Otherwise, return ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),". Both B and C are evaluated before ",(0,i.kt)("em",{parentName:"p"},"if")," is evaluated."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"x")," ",(0,i.kt)("em",{parentName:"p"},"raise exception")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(x X Y ...)")," takes an arbitrary number of arguments (even zero). Immediately fail, with the argument list passed up into the (python) exception. No other CLVM instructions are run after this instruction is evaluated."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"=")," ",(0,i.kt)("em",{parentName:"p"},"equal")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(= A B)")," returns 1 if ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," are both atoms and both equal. Otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),". Do not use this to test if two programs are identical. That is determined by their tree hash. Nil tests equal to zero, but nil is not equal to a single zero byte."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},">")," ",(0,i.kt)("em",{parentName:"p"},"greater than")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(> A B)")," returns 1 if ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," are both atoms and A is greater than B, interpreting both as two's complement signed integers. Otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"(> A B)")," means ",(0,i.kt)("inlineCode",{parentName:"p"},"A > B")," in infix syntax."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},">s")," ",(0,i.kt)("em",{parentName:"p"},"greater than bytes")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(>s A B)")," returns 1 if ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B")," are both atoms and A is greater than B, interpreting both as an array of unsigned bytes. Otherwise ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),". Compare to strcmp.\n",(0,i.kt)("inlineCode",{parentName:"p"},'(>s "a" "b")')," => ",(0,i.kt)("inlineCode",{parentName:"p"},"()")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"not")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(not A)")," returns 1 if ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," evaluates to ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),". Otherwise, returns ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"all")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(all A B ...)")," takes an arbitrary number of arguments (even zero). Returns ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," if any of the arguments evaluate to ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),". Otherwise, returns 1."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"any")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(any A B ...)")," takes an arbitrary number of arguments (even zero). Returns 1 if any of the arguments evaluate to something other than ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),". Otherwise, returns ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),"."),(0,i.kt)("h2",{id:"constants"},"Constants"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"q")," ",(0,i.kt)("em",{parentName:"p"},"quote")," The form ",(0,i.kt)("inlineCode",{parentName:"p"},"(q . X)")," when evaluated returns X, which is ",(0,i.kt)("em",{parentName:"p"},"not")," evaluated.\nExample: ",(0,i.kt)("inlineCode",{parentName:"p"},'(q . "A")')," => ",(0,i.kt)("inlineCode",{parentName:"p"},"65")),(0,i.kt)("h2",{id:"integer-operators"},"Integer Operators"),(0,i.kt)("p",null,"The arithmetic operators ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"divmod")," treat their arguments as signed integers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"+"))," ",(0,i.kt)("inlineCode",{parentName:"p"},"(+ a0 a1 ...)")," takes any number of integer operands and sums them. If given no arguments, zero is returned."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"-"))," ",(0,i.kt)("inlineCode",{parentName:"p"},"(- a0 a1 ...)")," takes one or more integer operands and adds a0 to the negative of the rest. Giving zero arguments returns 0."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"*"))," ",(0,i.kt)("inlineCode",{parentName:"p"},"(* a0 a1 ...)")," takes any number of integer operands and returns the product."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"/"))," ",(0,i.kt)("inlineCode",{parentName:"p"},"(/ A B)")," divides two integers and returns the floored quotient"),(0,i.kt)("h3",{id:"rounding"},"Rounding"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(/ 1  2) => ()\n(/ 2  2) => 1\n(/ 4  2) => 2\n")),(0,i.kt)("h3",{id:"division-of-negative-numbers"},"Division of negative numbers"),(0,i.kt)("p",null,"The treatment of negative dividend and divisors is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(/ -1 1) => -1\n(/ 1 -1) => -1\n(/ -1 -1) =>  1\n")),(0,i.kt)("h3",{id:"flooring-of-negative-nubmers"},"Flooring of negative nubmers"),(0,i.kt)("p",null,"Note that a division with a remainder always rounds towards negative infinity, not toward zero."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(/ -3 2) => -2\n(/ 3 2) => 1\n")),(0,i.kt)("p",null,"This means that ",(0,i.kt)("inlineCode",{parentName:"p"},"-a / b")," is not always equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"-(a / b)")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"divmod")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(divmod A B)")," takes two integers and returns a cons-box containing the floored quotient and the remainder."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(divmod 10 3)\n   => (3 . 1)\n")),(0,i.kt)("h2",{id:"bit-operations"},"Bit Operations"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"logand"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logior")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"logxor")," operate on any number of arguments\nnil as an argument to these functions is treated as a zero.\nFail if either A or B is not an atom.\nThe shorter atom is sign-extended to equal length as the longer atom."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"logand"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"logior")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"logxor")," accept 0 or more parameters.\nThere is an implicit ",(0,i.kt)("em",{parentName:"p"},"identity")," argument, which is the value all parameters will apply to.\nThe identity will just be returned in case 0 arguments are given."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"logand")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(logand A B ...)")," bitwise ",(0,i.kt)("strong",{parentName:"p"},"AND")," of one or more atoms. Identiy is ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(logand -128 0x7fffff)\n   => 0x7fff80\n")),(0,i.kt)("p",null,"The first argument is ",(0,i.kt)("inlineCode",{parentName:"p"},"0x80")," (since it's Two's complement). It is negative, it will be sign-extended with ones.\nOnce sign-extended, the computation becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"0xffff80")," AND ",(0,i.kt)("inlineCode",{parentName:"p"},"0x7fffff")," = ",(0,i.kt)("inlineCode",{parentName:"p"},"0x7fff80"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"logior")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(logior A B ...)")," bitwise logical ",(0,i.kt)("strong",{parentName:"p"},"OR")," of one or more atoms. Identity is ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(logior -128 0x7fffff)\n   => -1\n")),(0,i.kt)("p",null,"Sign extending the first argument becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"0xffff80"),", ORing that with ",(0,i.kt)("inlineCode",{parentName:"p"},"0x7fffff")," becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"0xffffff")," which is -1 in Two's complement.\nNote that the resulting atom will use the minimal encoding of ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),", i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"0xff"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"logxor")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(logxor A B ...)")," bitwise ",(0,i.kt)("strong",{parentName:"p"},"XOR")," of any number of atoms. Identity is ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(logxor -128 0x7fffff)\n   => 0x80007f\n")),(0,i.kt)("p",null,"Sign extending the first argument becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"0xffff80"),", XORing that with ",(0,i.kt)("inlineCode",{parentName:"p"},"0x7fffff")," becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"0x80007f"),".\nThis is a negative number (in Two's complement) and it's also the minimal representation of it."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"lognot")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(lognot A)")," bitwise ",(0,i.kt)("strong",{parentName:"p"},"NOT")," of A. All bits are inverted."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(lognot ()) => -1\n(lognot 1) => -2\n(lognot (lognot 17)) => 17\n")),(0,i.kt)("h2",{id:"shifts"},"Shifts"),(0,i.kt)("p",null,"There are two variants of bit shift operators.\nArithmetic shift (",(0,i.kt)("inlineCode",{parentName:"p"},"ash"),") and Logical shift (",(0,i.kt)("inlineCode",{parentName:"p"},"lsh"),"). Both can be used to shift both left and right, the direction is determined by the sign of the ",(0,i.kt)("em",{parentName:"p"},"count")," argument.\nA positive ",(0,i.kt)("em",{parentName:"p"},"count")," shifts left, a negative ",(0,i.kt)("em",{parentName:"p"},"count")," shifts right.\nFor both ",(0,i.kt)("strong",{parentName:"p"},"ash")," and ",(0,i.kt)("strong",{parentName:"p"},"lsh"),", if |",(0,i.kt)("em",{parentName:"p"},"count"),"| exceeds 65535, the operation fails.\nThe resulting value is treated as a signed integer, and any redundant leading zero-bytes or ",(0,i.kt)("inlineCode",{parentName:"p"},"0xff")," bytes are stripped."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"ash")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(ash A count)")," if ",(0,i.kt)("em",{parentName:"p"},"count")," is positive, return ",(0,i.kt)("em",{parentName:"p"},"A")," shifted left ",(0,i.kt)("em",{parentName:"p"},"count")," bits, else returns ",(0,i.kt)("em",{parentName:"p"},"A")," shifted right by |",(0,i.kt)("em",{parentName:"p"},"count"),"| bits, sign extended."),(0,i.kt)("p",null,"Arithmetic shift treats the value to be shifted (",(0,i.kt)("em",{parentName:"p"},"A"),") as a signed integer, and sign extends the left-most bits when when shifting right."),(0,i.kt)("p",null,"When shifting left, any new bytes added to the left side of the value are also filled with the sign-extended bit. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(ash -1 8) ; -1 = . . . 11111111\n   => -256 ; -256 = . . 1111111100000000\n")),(0,i.kt)("p",null,"A arithmetic left shift will only extend the atom length when more bits are needed"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(strlen (ash -1 7))\n   => 1\n(strlen (ash -1 8))\n   => 2\n(strlen (ash 255 1))\n  => 2\n(strlen (ash 128 1))\n  => 2\n(strlen (ash 127 1))\n  => 2\n")),(0,i.kt)("p",null,"Consecutive right shifts of negative numbers will result in a terminal value of -1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(ash -7 -1) ; -7 = . . . 11111001\n   => -4\n(ash -4 -1) ; -4 = . . . 11111100\n   => -2\n(ash -2 -1) ; -2 = . . . 11111110\n   => -1\n(ash -1 -1) ; -1 = . . . 11111111\n   => -1\n")),(0,i.kt)("p",null,"A right shift of ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")," by any amount is still ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(ash -1 -99)\n   => -1\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"lsh")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(lsh A count)")," if ",(0,i.kt)("em",{parentName:"p"},"count")," is positive, return ",(0,i.kt)("em",{parentName:"p"},"A")," shifted left ",(0,i.kt)("em",{parentName:"p"},"count")," bits, else returns ",(0,i.kt)("em",{parentName:"p"},"A")," shifted right |",(0,i.kt)("em",{parentName:"p"},"count"),"| bits, adding zero bits on the left."),(0,i.kt)("p",null,"Logical shift treats the value to be shifted as an unsigned integer, and does not sign extend on right shift."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(lsh -7 -1) ; -7 = . . . 11111001\n   => 124   ;    = . . . 01111100\n\n(lsh -5 -2) ; -5 = . . . 11111011\n   => 62    ;    = . . . 00111110\n")),(0,i.kt)("p",null,"A left shift of an atom with the high bit set will extend the atom left, and result in an allocation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(lsh -1 1) ; -1 = . . . 11111111\n   => 510  ;    = . . . 0000000111111110\n(strlen (lsh -1 1))\n   => 2\n(strlen (lsh 255 1))\n  => 2\n(strlen (lsh 128 1))\n  => 2\n(strlen (lsh 127 1))\n  => 2\n")),(0,i.kt)("h2",{id:"strings"},"Strings"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"substr")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(substr S I1 I2)")," return an atom containing the bytes in range ","[",(0,i.kt)("inlineCode",{parentName:"p"},"I1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"I2"),"). Index 0 refers to the first byte of the string ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"I2")," must be greater than or equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"I1"),". Both ",(0,i.kt)("inlineCode",{parentName:"p"},"I1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"I2")," must be greater than or equal to 0, and less than or equal to one past the end of the string ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("p",null,"The third parameter to ",(0,i.kt)("inlineCode",{parentName:"p"},"substr")," is optional. If omitted, the range ","[",(0,i.kt)("inlineCode",{parentName:"p"},"I1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"(strlen S)"),") is returned."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'(substr "clvm" 0 4) => "clvm"\n(substr "clvm" 2 4) => 30317 ; = "vm"\n(substr "clvm" 4 4) => ()\n\n(substr "clvm" 1) => "lvm"\n\n(substr "clvm" 4 5) => FAIL\n(substr "clvm" 1 0) => FAIL\n(substr "clvm" -1 4) => FAIL\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"strlen")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(strlen S)")," return the number of bytes in ",(0,i.kt)("inlineCode",{parentName:"p"},"S"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'(strlen "clvm") => 4\n(strlen "0x0") => 3\n(strlen 0x0) => 1\n(strlen "") => ()\n(strlen 0) => ()\n(strlen ()) => ()\n(strlen ()) => ()\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"concat")," ",(0,i.kt)("inlineCode",{parentName:"p"},"(concat A ...)")," return the concatenation of any number of atoms."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'(concat "Hello" " " "world")\n   => "Hello world"\n')),(0,i.kt)("h2",{id:"streaming-operators"},"Streaming Operators"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"sha256"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"(sha256 A ...)")," returns the sha256 hash (as a 32-byte blob) of the bytes of its parameters."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},'(sha256 "clvm")\n   => 0xcf3eafb281c0e0e49e19c18b06939a6f7f128595289b08f60c68cef7c0e00b81\n(sha256 "cl" "vm")\n   => 0xcf3eafb281c0e0e49e19c18b06939a6f7f128595289b08f60c68cef7c0e00b81\n')),(0,i.kt)("h2",{id:"bls12-381-operators"},"BLS12-381 operators"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"point_add")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pubkey_for_exp")," operate on G1 points of the BLS12-381 curve. These are represented as 48 bytes == 384 bits."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(strlen (pubkey_for_exp 1))\n   => 48\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"point_add"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"(point_add a0 a1 ...)")," takes an arbitrary number of ",(0,i.kt)("a",{parentName:"p",href:"https://electriccoin.co/blog/new-snark-curve/"},"BLS12-381")," G1 points and adds them."),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(point_add (pubkey_for_exp 1) (pubkey_for_exp 2))\n   => 0x89ece308f9d1f0131765212deca99697b112d61f9be9a5f1f3780a51335b3ff981747a0b2ca2179b96d2c0c9024e5224\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"pubkey_for_exp"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"(pubkey_for_exp A)")," turns the integer A into a BLS12-381 point on G1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-chialisp"},"(pubkey_for_exp 1)\n   => 0x97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\n")),(0,i.kt)("h2",{id:"softfork"},"softfork"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"softfork")," operator takes at least one parameter cost. So ",(0,i.kt)("inlineCode",{parentName:"p"},"(softfork cost arg_1 ... arg_n)"),"."),(0,i.kt)("p",null,"At the moment, ",(0,i.kt)("inlineCode",{parentName:"p"},"softfork")," always returns ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," (aka ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," or nil), and takes ",(0,i.kt)("inlineCode",{parentName:"p"},"cost")," amount of cost."),(0,i.kt)("p",null,"At first glance, it seems pretty useless since it doesn't do anything, and just wastes cost doing it."),(0,i.kt)("p",null,"The idea is, after a soft fork, the meaning of the arguments may change. In fact, we can hide completely new dialects of ChiaLisp inside here, that has new operators that calculate new things."),(0,i.kt)("p",null,"For example, suppose we want to add secp256k1 operators like ",(0,i.kt)("inlineCode",{parentName:"p"},"+s")," for adding two points on this ECDSA curve for bitcoin compatibility. We can't just do this in vanilla clvm because that would make a program ",(0,i.kt)("inlineCode",{parentName:"p"},"(+s p1 p2)")," return different values before and after the soft fork. So instead we hide it under ",(0,i.kt)("inlineCode",{parentName:"p"},"softfork"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(mod (cost p1 p2 p3 p4) (softfork cost 1 (assert (= (+s p1 p2) (+s p3 p4)))))")),(0,i.kt)("p",null,"Pre-softfork, this always passes and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," at a cost of ",(0,i.kt)("inlineCode",{parentName:"p"},"COST")," (plus a bit of overhead)."),(0,i.kt)("p",null,"Post-softfork, this also returns ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," at a cost of ",(0,i.kt)("inlineCode",{parentName:"p"},"COST"),"... but may also fail if ",(0,i.kt)("inlineCode",{parentName:"p"},"p1 + p2 \u2260 p3 + p4"),"! We can't export the sum outside the ",(0,i.kt)("inlineCode",{parentName:"p"},"softfork")," boundary, but we can calculate the sum and compare it to another thing inside."),(0,i.kt)("p",null,"One more thing -- we take the cost of running the program inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"softfork")," boundary and ensure it exactly matches ",(0,i.kt)("inlineCode",{parentName:"p"},"COST"),", and raise an exception if it's wrong. That way, the program really does have the same cost pre and post-softfork (or it fails post-softfork)."),(0,i.kt)("h2",{id:"arithmetic-and-bitwise-identities"},"Arithmetic and Bitwise Identities"),(0,i.kt)("p",null,"Some operators have a special value that is returned when they are called with zero arguments. This value is the identity of that function. For example, calling the operator ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," with zero arguments will return ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"(+)")," => ",(0,i.kt)("inlineCode",{parentName:"p"},"0")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Identity"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"+")),(0,i.kt)("td",{parentName:"tr",align:null},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"-")),(0,i.kt)("td",{parentName:"tr",align:null},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"*")),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"logand"),(0,i.kt)("td",{parentName:"tr",align:null},"all 1's")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"logior"),(0,i.kt)("td",{parentName:"tr",align:null},"all zeros")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"logxor"),(0,i.kt)("td",{parentName:"tr",align:null},"all zeros")))),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"/"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"divmod"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"lognot")," do not have an identity value. Calling them with zero arguments is an error."),(0,i.kt)("h2",{id:"arithmetic"},"Arithmetic"),(0,i.kt)("h3",{id:"behaviour-of-nil-when-used-as-an-integer"},"Behaviour of nil when used as an integer"),(0,i.kt)("p",null,"When used in an integer context, nil behaves as zero."),(0,i.kt)("h3",{id:"behaviour-of-zero-when-used-as-a-value-that-may-be-checked-for-nil"},"Behaviour of zero when used as a value that may be checked for nil"),(0,i.kt)("p",null,"When used as a parameter that may be checked for nil, zero is interpreted as nil."),(0,i.kt)("h2",{id:"costs"},"Costs"),(0,i.kt)("p",null,"When a CLVM program is run, a cost is attributed to it. The minimum program cost is 40. The maximum cost per block is 11,000,000,000. If the cost of an individual program exceeds this threshold, the program will be terminated and no value will be returned."),(0,i.kt)("p",null,"There are three contributors to a CLVM program's total cost:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Its size in bytes, where each byte has a cost of 12,000."),(0,i.kt)("li",{parentName:"ol"},"The total computational cost of the CLVM operators that are executed in the program. The cost of these operators is listed below."),(0,i.kt)("li",{parentName:"ol"},"The conditions outputted by the program. Only three conditions incur a cost: ",(0,i.kt)("inlineCode",{parentName:"li"},"CREATE_COIN"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"AGG_SIG_UNSAFE"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"AGG_SIG_ME"),", which are also listed below.")),(0,i.kt)("p",null,"These three contributors are balanced so that they each contribute approximately the same amount of cost in a block full of standard transactions."),(0,i.kt)("p",null,"The theoretical maximum size of a single block is 11,000,000,000 / 12,000 = 916,666 bytes. However, if you want to run a program that uses CLVM operators and conditions, the effective maximum size is ~500 KB."),(0,i.kt)("p",null,"Even this number is not realistic because it assumes that a single program will take up an entire block. The maximum number of vanilla transactions per block is ~2000. Therefore, if there is fee pressure on Chia's blockchain, a 500 KB program would need to include a larger fee than the top 2000 vanilla transactions in the mempool -- combined -- in order for a farmer to include it."),(0,i.kt)("p",null,"To determine the total cost of a clvm program, you can run ",(0,i.kt)("inlineCode",{parentName:"p"},"brun -c <clvm>"),"."),(0,i.kt)("p",null,"The following table shows the cost of each CLVM operator, as well as the cost of the outputted conditions."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"operator"),(0,i.kt)("th",{parentName:"tr",align:null},"base cost"),(0,i.kt)("th",{parentName:"tr",align:null},"cost per arg"),(0,i.kt)("th",{parentName:"tr",align:null},"cost per byte"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"f")," ",(0,i.kt)("em",{parentName:"td"},"first")),(0,i.kt)("td",{parentName:"tr",align:null},"30"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"i")," ",(0,i.kt)("em",{parentName:"td"},"if")),(0,i.kt)("td",{parentName:"tr",align:null},"33"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"c")," ",(0,i.kt)("em",{parentName:"td"},"cons")),(0,i.kt)("td",{parentName:"tr",align:null},"50"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"r")," ",(0,i.kt)("em",{parentName:"td"},"rest")),(0,i.kt)("td",{parentName:"tr",align:null},"30"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"l")," ",(0,i.kt)("em",{parentName:"td"},"listp")),(0,i.kt)("td",{parentName:"tr",align:null},"19"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"q")," ",(0,i.kt)("em",{parentName:"td"},"quote")),(0,i.kt)("td",{parentName:"tr",align:null},"20"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"a")," ",(0,i.kt)("em",{parentName:"td"},"apply")),(0,i.kt)("td",{parentName:"tr",align:null},"90"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"=")),(0,i.kt)("td",{parentName:"tr",align:null},"117"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"+")),(0,i.kt)("td",{parentName:"tr",align:null},"99"),(0,i.kt)("td",{parentName:"tr",align:null},"320"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"/")),(0,i.kt)("td",{parentName:"tr",align:null},"988"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"*")),(0,i.kt)("td",{parentName:"tr",align:null},"92"),(0,i.kt)("td",{parentName:"tr",align:null},"885"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"https://github.com/Chia-Network/clvm_tools/blob/main/costs/README.md#multiplication"},"see here"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"logand"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"logior"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"logxor")),(0,i.kt)("td",{parentName:"tr",align:null},"100"),(0,i.kt)("td",{parentName:"tr",align:null},"264"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"lognot")),(0,i.kt)("td",{parentName:"tr",align:null},"331"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},">")),(0,i.kt)("td",{parentName:"tr",align:null},"498"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},">s")),(0,i.kt)("td",{parentName:"tr",align:null},"117"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"strlen")),(0,i.kt)("td",{parentName:"tr",align:null},"173"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"concat")),(0,i.kt)("td",{parentName:"tr",align:null},"142"),(0,i.kt)("td",{parentName:"tr",align:null},"135"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"divmod")),(0,i.kt)("td",{parentName:"tr",align:null},"1116"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"6")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sha256")),(0,i.kt)("td",{parentName:"tr",align:null},"87"),(0,i.kt)("td",{parentName:"tr",align:null},"134"),(0,i.kt)("td",{parentName:"tr",align:null},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ash")),(0,i.kt)("td",{parentName:"tr",align:null},"596"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"lsh")),(0,i.kt)("td",{parentName:"tr",align:null},"277"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"not"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"any"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"all")),(0,i.kt)("td",{parentName:"tr",align:null},"200"),(0,i.kt)("td",{parentName:"tr",align:null},"300"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"point_add")),(0,i.kt)("td",{parentName:"tr",align:null},"101094"),(0,i.kt)("td",{parentName:"tr",align:null},"1343980"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"pubkey_for_exp")),(0,i.kt)("td",{parentName:"tr",align:null},"1325730"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"38")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"CREATE_COIN")),(0,i.kt)("td",{parentName:"tr",align:null},"1800000"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"AGG_SIG_UNSAFE"),",",(0,i.kt)("inlineCode",{parentName:"td"},"AGG_SIG_ME")),(0,i.kt)("td",{parentName:"tr",align:null},"1200000"),(0,i.kt)("td",{parentName:"tr",align:null},"-"),(0,i.kt)("td",{parentName:"tr",align:null},"-")))),(0,i.kt)("p",null,"Aside from cost, the maximum number of atoms or pairs in a CLVM program is 2^31. If this threshold is exceeded, the program will be terminated and no value will be returned."))}u.isMDXComponent=!0}}]);